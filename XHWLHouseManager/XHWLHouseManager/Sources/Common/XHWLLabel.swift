//
//  UILabel+Extension.swift
//  XHWLHouseManager
//
//  Created by gongairong on 2017/9/26.
//  Copyright © 2017年 XHWL. All rights reserved.
//

import UIKit

class XHWLLabel: UILabel {
    
//    enum VerticalAlignment:NSInteger  {
//        case VerticalAlignmentTop = 0 // default
//        case VerticalAlignmentMiddle
//        case VerticalAlignmentBottom
//    }
//
//    var verticalAlignment:VerticalAlignment! {
//        willSet {
//            if (newValue != nil) {
//                                                                             
//                self.setNeedsDisplay()
//            }
//        }
//    }
//
//    override init(frame:CGRect) {
//        super.init(frame)
//        
//        self.verticalAlignment = .VerticalAlignmentMiddle
//    }
//    
//    required init?(coder aDecoder: NSCoder) {
//        fatalError("init(coder:) has not been implemented")
//    }
    

    
//    - (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines {
//    }
    
//    func textRectForBounds(_ bounds:CGRect, _ numberOfLines:NSInteger) -> CGRect {
//        
//        let textRect:CGRect = super.textRectForBounds [super textRectForBounds:bounds limitedToNumberOfLines:numberOfLines];
//        switch (self.verticalAlignment) {
//        case VerticalAlignmentTop:
//            textRect.origin.y = bounds.origin.y;
//            break;
//        case VerticalAlignmentBottom:
//            textRect.origin.y = bounds.origin.y + bounds.size.height - textRect.size.height;
//            break;
//        case VerticalAlignmentMiddle:
//        // Fall through.
//        default:
//            textRect.origin.y = bounds.origin.y + (bounds.size.height - textRect.size.height) / 2.0;
//        }
//        return textRect;
//
//    }
//    
//    func drawTextInRect(requestedRect:CGRect) {
//    
////        let actualRect:CGRect = 
//        
////        CGRect actualRect = [self textRectForBounds:requestedRect limitedToNumberOfLines:self.numberOfLines];
////        [super drawTextInRect:actualRect];
//    }
    
}
